#include<iostream>

using std::cin;
using std::cout;

// Point - име на структурата, т.е. нашият нов тип данни
struct Point
{
    double x; // поле x, т.е. всяка променлива тип Point си има _свой_ x.
    double y;
};

// Въпреки, че двете структури са с еднакво вътрешно разположение на данните,
// те носят различен смисъл. Тогава ако имамe Point p1,p2; Rational r,
// можем да напишем p1 = p2, но не и p1 = r - това са различни типове все пак.
struct Rational
{
    double num;
    double denom;
};

// Може стурктурите са съдържат и статични масиви
struct PointN
{
    // инициализация на член-данните - само от c++11 насам е позволено!
    double coords[7] = { 1, 2 };
};

// Възможно е структура да съдържа други структури и т.н.,
// при което напр. x координатата на точка b на триъгълник tr
// се достъпва по следния начин: cout << tr.b.x;
struct Triangle
{
    Point a;
    Point b;
    Point c;
};

// Тъй като това е "нов" тип, компилаторът не знае как да го изведе
// на стандартния изход. Тогава си правим малка функцийка за тази цел.
void print(Point p)
{
    cout << "Coordinates are: {" << p.x << "," << p.y << "}.\n";
}

// Две структури с едни и съши съдържани данни, но различен layout
// => различен размер на обектите от тези два типа.
struct A
{
    char c;
    double d;
    int n;
};

struct B
{
    double d;
    int n;
    char c;
};

int szA = sizeof(A); // == 24
int szB = sizeof(B); // == 16

int main()
{
    // това, че имаме променлива с име x, не влияе на
    // член-данните със същото име - няма конфликт, понеже се
    // знае, че се обръщаме към член-данни с оператора "."
    int x = 5;
    
    PointN pn, pn2;
    // променяме двата обекта от тип PointN
    for (int i = 0; i < 7; i++)
        pn.coords[i] = 0;
    pn2.coords[0] = 5;

    cout << "{";
    for (int i = 0; i < 7; i++)
        cout << pn.coords[i] << " ";
    cout << "}\n\n";

    cout << "{";
    for (int i = 0; i < 7; i++)
        cout << pn2.coords[i] << " ";
    cout << "}\n\n";

    // Забранено
    /*cin >> pn;
    cout << pn;*/

    Point p;
    // за да въведем структурата, въвеждаме член-данните й (не винаги е необходимо)
    cin >> p.x >> p.y;
    // извършваме изчисления с тях
    p.x = -2*p.x;
    p.y = -3 * p.y + 10;
    // функцията за отпечатване отново отпечатва член-данните,
    // но ги "скрива" за нас. Хубаво е повечето процедури за работа с такива структури
    // също да са отделни функции, които приемат такива структури като аргументи.
    print(p);

    // Позволено е копиране/присвояване
    Point p2 = p;
    print(p2);

    // Можем и ръчно да го направим, но става автоматично
    /*p2.x = p.x;
    p2.y = p.y;*/

    // създаваме масиви от нашите типове така, както от всички "обикновени" типове
    float floatArray[10];
    Point points[8];
}
